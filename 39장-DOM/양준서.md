# 39장 DOM

- DOM(Document Object Model) HTML 문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 API,
- 즉 프로퍼티와 메서드를 제공하는 트리 자료구조

- 가능한 책을 기준으로 보는 것이 더 효율적으로 보인다. 정리로 보는 것 보다 더 이해가 잘 될 것으로 예상

## 39.1 노드

### 39.1.1 HTML 요소와 노드 객체

# 678p 위 이미지

- 트리 자료 구조
  - 노드들의 계층 구조로 이루어진다. 부모, 자식 노드로 구성되어 계층적 구조를 표현하는 비선형 자료구조이다.

# 678p 아래 이미지

### 39.1.2 노드 객체의 타입

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
    <script src="app.js"></script>
  </body>
</html>
```

# 679p 이미지

- 렌더링 엔진은 HTML 문서를 파싱하여 위와 같은 DOM을 생성한다

### 39.1.3 노드 객체의 상속 구조

- DOM은 HTML 문서의 계층적 구조와 정보를 표현하며,
- 이를 제어할 수 있는 API, 즉 프로퍼티의 메서드를 제공하는 트리 자료 구조이다.

# 681p 이미지

## 39.2 요소 노드 취득

- HTML 요소를 조작하는 시작점. DOM은 요소 노드를 취득할 수 있는 다양한 메서드를 제공

### 39.2.1 id를 이용한 요소 노드 취득

- Document.prototype.getElementById 메서드는 인수로 전달한 `id 어트리뷰트` 값을 갖는 하나의 요소 노드를 탐색하여 반환한다.

### 39.2.2 태그 이름을 이용한 요소 노드 취득

- Document.prototype/Element.prototype.getElementsByTagName 메서드는 인수로 전달한 태그 이름을 갖는 `모든 요소 노드`들을 탐색하여 반환한다.

- document.getElementsByTagName('li')
- document로 해도 되고, Element로 해도 되며 인수로 전달한 태그 이름 요소가 없는 경우에는 `빈 HTMLCollection 객체`를 반환한다.

### 39.2.3 class를 이용한 요소 노드 취득

- Document.prototype/Element.prototype.getElementsByClassName
  - 인수로 전달한 `class` 어트리뷰트 값을 갖는 `모든 요소 노드들`을 탐색하여 반환
  - 인수로 전달한 class가 존재하지 않으면 `빈 HTMLCollection 객체`를 반환한다.

### 39.2.4 CSS 선택자를 이용한 요소 노드 취득

- Document.prototype/Element.prototype.querySelector

  - 인수로 전달한 CSS 선택자를 만족시키는 하나의 요소 노드를 탐색하여 반환
  - document.querySelector(.banana) / document.querySelectorAll('ul > li')

- CSS 선택자로 좀 더 구체적인 조건, 일관된 방식으로 요소 노드 취득이 가능하지만, getElementById, getElementsBy\*\*\* 등 보다는 다소 느린 측면은 있다고 한다.

### 39.2.5 특정 요소 노드를 취득할 수 있는지 확인

- Elements.prototype.matches
  - 인수로 전달된 CSS 선택자를 통해 특정 요소 노드를 취득할 수 있는지 확인

### 39.2.6 HTMLCollection과 NodeList

- HTMLCollection, NodeList는 DOM API가 여러 개의 결과값을 반환하기 위한 DOM 컬렉션 객체이다.
- 유사 배열 객체이며 이터러블하다
- 위의 2개는 노드 객체의 상태 변화를 `실시간`으로 반영하는 개체라는 것이 중요 포인트이다.
- NodeList는 대부분 노드 객체의 상태 변화를 실시간 반영하지 않고 과거의 정적 상태를 유지한다

**[ HTMLCollection ]**

- getElementsByTagName, getElementsByClassName 메서드가 반환하는 HTMLCOllection 객체는 노드 객체의 상태 변화를 실시간으로 반영한다.

```html
<!DOCTYPE html>
<head>
  <style>
    .red {
      color: red;
    }
    .blue {
      color: blue;
    }
  </style>
</head>
<html>
  <body>
    <ul id="fruits">
      <li class="red">Apple</li>
      <li class="red">Banana</li>
      <li class="red">Orange</li>
    </ul>
    <script>
      // class 값이 'red'인 요소 노드를 모두 탐색하여 HTMLCollection 객체에 담아 반환한다.
      const $elems = document.getElementsByClassName("red");
      // 이 시점에 HTMLCollection 객체에는 3개의 요소 노드가 담겨 있다.
      console.log($elems); // HTMLCollection(3) [li.red, li.red, li.red]

      // HTMLCollection 객체의 모든 요소의 class 값을 'blue'로 변경한다.
      for (let i = 0; i < $elems.length; i++) {
        $elems[i].className = "blue";
      }

      // HTMLCollection 객체의 요소가 3개에서 1개로 변경되었다.
      console.log($elems); // HTMLCollection(1) [li.red]
    </script>
  </body>
</html>
```

# 696p 이미지

- 모두 blue가 되지 않게 되는데, 실시간이 특징이기 때문이다.

  - 첫 번째 반복 시 red에서 blue로 변경되었기에 $elems에서 삭제가 된다.
  - 그러면 결국 length가 3에서 2로 된 것임

- 여러 해결 방법이 있지만, 가능한 유사 배열 객체이므로 `배열`로 변환을 해서 사용하던가 혹은 아래와 같이 역순으로 도는 방법도 있다.

```javascript
// for 문을 역방향으로 순회
for (let i = $elems.length - 1; i >= 0; i--) {
  $elems[i].className = "blue";
}
```

**[ NodeList ]**

- querySelectorAll 메서드는 NodeList 객체를 반환한다.
- 실시간 반영이 아님

```javascript
// querySelectorAll은 DOM 컬렉션 객체인 NodeList를 반환한다.
const $elems = document.querySelectorAll(".red");

// NodeList 객체는 NodeList.prototype.forEach 메서드를 상속받아 사용할 수 있다.
$elems.forEach((elem) => (elem.className = "blue"));
```

결과적으로 HTMLCollection, NodeList를 활용하게 되는 경우에는 유사 배열 객체이기 때문에 사용할 필요가 생기면 `배열`로 변환해서 활용하는 것이 개발자 에러를 방지한다.

## 39.3 노드 탐색
