# 46. 제너레이터와 async/await
### 제너레이터(Generator)란?
> 코드 블록 실행 일시 중지 -> 원할 때 실행 가능
> * ES6 ~ 도입

#### 일반 함수와 비교되는 제네레이터의 특징
1. 함수 호출자에게 함수 제어권 넘길 수 있음(yield)
2. 함수 상태도 주고받음
3. 반환하는 건 제네레이터(Generator)객체
   * iterable이자 iterator라는 점이 특징
4. `function*`으로 표기, 1개 이상의 `yield` 표현식 존재
   * `*` 위치는 `function`과 함수명 사이
5. 화살표 함수X
6. new 생성자 함수로 호출X

<br/>

#### 활용처
1. iterable 구현이 상대적으로 간단해짐
   * 제네레이터 실행기 -> CO 라이브러리로
2. 비동기 처리: `then/catch/finally` 표현식 없이도 프로미스를 통해 비동치 처리를 동기 처리처럼 구현 가능


<br/>

#### async/await
* ES8+ 버전
* 프로미스 기반 동작
* `async/await`을 활용하면 프로미스의 `then/catch/finally` 후속 처리 메서드에 콜백 함수를 전달해서 비동기 처리 결과를 후속 처리할 필요 없이,<br>마치 동기 처리처럼 프로미스를 사용 가능하다
  * = 프로미스의 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하게끔 구현 가능

1. async 함수
   * 반드시 async 함수 내부에서 await 키워드 사용
   * async 키워드로 정의
   * 언제나 프로미스를 반환
   * 명시적으로 프로미스를 반환하지 않아도 암묵적으로 반환값을 resolve하는 프로미스를 반환함
   * 클래스 constructor 메서드는 async 메서드가 될 수 없음
2. await 함수
   * 프로미스가 settled 상태(비동기 처리 수행된 상태)가 될 때까지 대기하다가 settled 상태가 되면 프로미스가 resolve 한 처리 결과를 반환
     * 프로미스가 settled 상태가 되면 프로미스가 resolve한 결과가 res 변수에 할당됨
   * await 키워드는 반드시 프로미스 앞에서 사용해야 함
   * 모든 프로미스에 await 키워드를 사용하는 것은 주의해야 함


<br>

> 비동기 처리를 위한 콜백 패턴의 주요 단점: 에러 처리가 곤란하다는 점
> * async 함수 내에서 catch 문을 사용해서 에러 처리를 하지 않으면 async 함수는 발생한 에러를 reject하는 프로미스를 반환